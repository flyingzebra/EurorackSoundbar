<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vital-Style Envelope Curve – Canvas · v1.0</title>
  <style>
    :root { --bg:#0b0f14; --panel:#0f1621; --ink:#d8e2ff; --muted:#7b8aa5; --accent:#7dd3fc; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font:12px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:14px 16px;border-bottom:1px solid #1b2230;background:linear-gradient(180deg,rgba(255,255,255,.035),rgba(255,255,255,0));position:sticky;top:0}
    h1{font-size:16px;margin:0}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;padding:16px;min-height:calc(100vh - 54px)}
    .panel{background:var(--panel);border:1px solid #1a2332;border-radius:14px;padding:14px;box-shadow:0 10px 25px rgba(0,0,0,.25)}
    .row{display:grid;grid-template-columns:120px 1fr 90px;align-items:center;gap:8px;margin:8px 0}
    label{color:var(--muted)} input[type="range"]{width:100%} .value{font-variant-numeric:tabular-nums;color:var(--ink);text-align:right}
    canvas{width:100%;height:100%;display:block;border-radius:14px}
    .canvas-wrap{position:relative}
    .legend{position:absolute;top:10px;left:12px;font-size:12px;color:var(--muted)}
    .badge{display:inline-block;padding:2px 8px;border:1px solid #2a3750;border-radius:999px;margin-right:6px}
    .noteoff{position:absolute;top:0;bottom:0;width:1px;background:linear-gradient(var(--accent), transparent);} 
    .hint{color:#99a6c2;font-size:12px;margin-top:6px}
    .grid-toggle{display:flex;gap:6px;margin-top:8px}
    button{background:#122033;border:1px solid #24334d;color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
    button:hover{filter:brightness(1.1)}
    .sustain-level{position:absolute;left:0;right:0;height:1px;background:rgba(125,211,252,.2)}
  </style>
</head>
<body>
  <header>
    <h1>Vital‑style Envelope Curve (Delay / Attack / Hold / Decay / Sustain / Release) <span class="badge">v1.0</span></h1>
  </header>

  <div class="wrap">
    <section class="panel" id="controls">
      <div class="row"><label id="label_delay"></label><input id="delay" type="range" min="0" max="1.4142135381698608" step="0.0001" /><div class="value" id="delay_v"></div></div>
      
      <div class="row"><label id="label_attack"></label><input id="attack" type="range" min="0" max="2.378420114517212" step="0.0001" /><div class="value" id="attack_v"></div></div>
      <div class="row"><label id="label_attack_power"></label><input id="attack_power" type="range" min="-20" max="20" step="0.001" /><div class="value" id="attack_power_v"></div></div>
      <div class="row"><label id="label_hold"></label><input id="hold" type="range" min="0" max="1.4142135381698608" step="0.0001" /><div class="value" id="hold_v"></div></div>
      <div class="row"><label id="label_decay"></label><input id="decay" type="range" min="0" max="2.378420114517212" step="0.0001" /><div class="value" id="decay_v"></div></div>
      <div class="row"><label id="label_decay_power"></label><input id="decay_power" type="range" min="-20" max="20" step="0.001" /><div class="value" id="decay_power_v"></div></div>
      <div class="row"><label id="label_sustain"></label><input id="sustain" type="range" min="0" max="1" step="0.001" /><div class="value" id="sustain_v"></div></div>
      <div class="row"><label id="label_release"></label><input id="release" type="range" min="0" max="2.378420114517212" step="0.0001" /><div class="value" id="release_v"></div></div>
      <div class="row"><label id="label_release_power"></label><input id="release_power" type="range" min="-20" max="20" step="0.001" /><div class="value" id="release_power_v"></div></div>
      
      <div class="row" style="visibility: hidden"><label id="label_gate"></label><input id="gate" type="range" min="0" max="4" step="0.01" /><div class="value" id="gate_v"></div></div>
      
      <div class="grid-toggle"><button id="fit">Fit to View</button><button id="reset">Reset from preset</button></div>
      <p class="hint">Time sliders have Vital's logarithmic feel (power2=2 → x^4 in patch units) while values show seconds. Curve knobs are −20…+20.</p>

      <details style="margin-top:8px">
        <summary>Diagnostics / Tests</summary>
        <pre id="testout" style="white-space:pre-wrap;background:#0b1220;padding:8px;border-radius:8px;border:1px solid #1a2332"></pre>
      </details>
    </section>

    <section class="panel canvas-wrap">
      <canvas id="env"></canvas>
      <div class="legend">
        <span class="badge">Note On</span>
        <span class="badge">Delay</span>
        <span class="badge">Attack</span>
        <span class="badge">Hold</span>
        <span class="badge">Decay → Sustain</span>
        <span class="badge">Note Off</span>
        <span class="badge">Release</span>
      </div>
      <div class="legend" style="top:auto; bottom:10px;"><span class="badge">Midpoint markers (A/D/R)</span></div>
      <div class="noteoff" id="noteoff"></div>
      <div class="sustain-level" id="sustainLine" style="display:none"></div>
    </section>
  </div>

<script>
// === Config ===
const VERSION = 'v1.0';
const ENV_INDEX = 1; // configurable envelope number for labels

// 16-bit time domain for all time outcomes (no control buffer)
const MAX_ENVELOPE_SECONDS = 120;          // Hard cap for our envelope timeline
const U16_MAX = 65535;                      // 0..65535 ticks cover MAX_ENVELOPE_SECONDS
const SEC_PER_TICK = MAX_ENVELOPE_SECONDS / U16_MAX;
const TICKS_PER_SEC = U16_MAX / MAX_ENVELOPE_SECONDS;

// === Vital envelope 1 parameters read from the provided preset (RAW patch units) ===
const PRESET = 
{
  env_1_delay: 0.0,                        // 0..1.4142135381698608 ==> 0..4s
  env_1_attack: 1.0582560300827026,        // 0..2.378420114517212 ==> 0..32s
  env_1_attack_power: 3.1799983978271484,  // -20..+20 ==> -20..+20
  env_1_hold: 0.0,
  env_1_decay: 1.7736866474151611,         // 0..2.378420114517212 ==> 0..32s
  env_1_decay_power: -1.460000991821289,
  env_1_sustain: 0.7679197192192078,
  env_1_release: 1.3171406984329224,       // 0..2.378420114517212 ==> 0..32s
  env_1_release_power: -2.0,
  gate: 0 // sustain time before Note Off (seconds); not from patch here
};

// === Hard-coded parameter scaling (Vital patch units -> UI seconds / knob units)
// Time params use a power-law: seconds = secMax * (raw/rawMax)^(2^power2)  (with power2=2 ⇒ x^4)
const PARAM_SCALES = {
  env_attack:        { type:'pow2', rawMax: 2.378420114517212, secMax: 32, power2: 2 },
  env_decay:         { type:'pow2', rawMax: 2.378420114517212, secMax: 32, power2: 2 },
  env_release:       { type:'pow2', rawMax: 2.378420114517212, secMax: 32, power2: 2 },
  env_delay:         { type:'pow2', rawMax: 1.4142135381698608, secMax: 4,  power2: 2 },
  env_hold:          { type:'pow2', rawMax: 1.4142135381698608, secMax: 4,  power2: 2 },
  // Linear params
  env_sustain:       { type:'linear', factor: 1 },
  env_attack_power:  { type:'linear', factor: 1 },
  env_decay_power:   { type:'linear', factor: 1 },
  env_release_power: { type:'linear', factor: 1 }
};

// Power-law converters using repeated squaring (power2=number of squarings). Faster than Math.pow and
// correct for fractional inputs (bitwise shifts would coerce to 32-bit ints and are incorrect for 0..1).
function fromPatchUnitsPow2(raw, rawMax, secMax, power2){
  let x = raw / rawMax; if (x < 0) x = 0; else if (x > 1) x = 1;
  for (let i=0;i<power2;i++) x *= x; // power2=2 => x^4
  return secMax * x;
}
function toPatchUnitsPow2(seconds, rawMax, secMax, power2){
  let y = seconds / secMax; if (y < 0) y = 0; else if (y > 1) y = 1;
  for (let i=0;i<power2;i++) y = Math.sqrt(y); // power2=2 => 4th root
  return rawMax * y;
}

// Convert patch units -> UI units (seconds or knob)
function fromPatchUnits(name, value){
  const e = PARAM_SCALES[name];
  if (!e) return value;
  if (e.type === 'pow2') return fromPatchUnitsPow2(value, e.rawMax, e.secMax, e.power2);
  return value * (e.factor ?? 1);
}
// Convert UI units -> patch units (for export)
function toPatchUnits(name, value){
  const e = PARAM_SCALES[name];
  if (!e) return value;
  if (e.type === 'pow2') return toPatchUnitsPow2(value, e.rawMax, e.secMax, e.power2);
  const f = (e.factor ?? 1);
  return f !== 0 ? value / f : 0;
}

// === Helpers ===
function lerp(a,b,t){ return a + (b-a) * t; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// Vital-ish power curve (approximation): p=0 linear; +ve ease-in, -ve ease-out.
function powerCurve01(x, p){
  x = clamp(x, 0, 1);
  if (Math.abs(p) < 1e-6) return x;
  const abs = Math.min(20, Math.abs(p));
  const maxE = 9;
  const e = 1 + (maxE - 1) * (abs / 20);
  return (p > 0) ? Math.pow(x, e) : 1 - Math.pow(1 - x, e);
}

// (Kept for future: where the mapping deviates most from y=x)
function bendXForPower(p){
  const pp = -p;
  if (Math.abs(pp) < 1e-6) return 0.5;
  let bestX = 0.5, bestD = -1;
  const N = 256;
  for(let i=0;i<=N;i++){
    const x = i/N; const d = Math.abs(powerCurve01(x, pp) - x);
    if (d>bestD){ bestD=d; bestX=x; }
  }
  return bestX;
}

// Evaluate the envelope (0..1) at time t (seconds)
function evalEnvelope(params, t){
  const {delay, attack, attack_power, hold, decay, decay_power, sustain, release, release_power, gate} = params;
  const tDelayEnd   = delay;
  const tAttackEnd  = tDelayEnd + attack;
  const tHoldEnd    = tAttackEnd + hold;
  const tDecayEnd   = tHoldEnd   + decay;
  const tNoteOff    = tDecayEnd  + gate;
  const tReleaseEnd = tNoteOff   + release;

  if (t < tDelayEnd) return 0.0;
  if (t < tAttackEnd){
    const x = (t - tDelayEnd) / Math.max(attack, 1e-9);
    return powerCurve01(x, attack_power);
  }
  if (t < tHoldEnd) return 1.0;
  if (t < tDecayEnd){
    const x = (t - tHoldEnd) / Math.max(decay, 1e-9);
    return lerp(1.0, sustain, powerCurve01(x, decay_power));
  }
  if (t < tNoteOff) return sustain;
  if (t < tReleaseEnd){
    const x = (t - tNoteOff) / Math.max(release, 1e-9);
    return lerp(sustain, 0.0, powerCurve01(x, release_power));
  }
  return 0.0;
}

function totalLength(p){ return p.delay + p.attack + p.hold + p.decay + p.gate + p.release; }


function secToTicks(s){ if (!Number.isFinite(s) || s <= 0) return 0; const t = Math.round(s * TICKS_PER_SEC); return t < 0 ? 0 : (t > U16_MAX ? U16_MAX : t); }
function ticksToSec(t){ return t * SEC_PER_TICK; }

function F2I(_float)
{
    return 1024 * (_float + 20)
}

function I2F(_uint32)
{
    return (_uint32/1024) -20;
}
  
// Build timeline boundaries in 16-bit ticks (integers). Midpoints are exact mid-ticks.
// Index map:
//  0 NOTE_ON (0)
//  1 DELAY_END
//  2 ATTACK_MID
//  3 ATTACK_END
//  4 HOLD_MID
//  5 HOLD_END
//  6 DECAY_MID
//  7 DECAY_END
//  8 NOTE_OFF
//  9 RELEASE_MID
// 10 RELEASE_END
// 11 TOTAL_END (== RELEASE_END)
function computeTimeline(p){
  const b = new Uint16Array(12);
  b[0] = 0;
  let vSec = 0;
  // Delay
  vSec += p.delay; b[1] = secToTicks(vSec);
  // Attack
  const aStart = b[1]; vSec += p.attack; const aEnd = secToTicks(vSec); b[2] = (aStart + aEnd) >>> 1; b[3] = aEnd;
  // Hold
  const hStart = b[3]; vSec += p.hold;   const hEnd = secToTicks(vSec); b[4] = (hStart + hEnd) >>> 1; b[5] = hEnd;
  // Decay
  const dStart = b[5]; vSec += p.decay;  const dEnd = secToTicks(vSec); b[6] = (dStart + dEnd) >>> 1; b[7] = dEnd;
  // Gate (note on to off)
  vSec += p.gate; b[8] = secToTicks(vSec);
  // Release
  const rStart = b[8]; vSec += p.release; const rEnd = secToTicks(vSec); b[9] = (rStart + rEnd) >>> 1; b[10] = rEnd;
  // Total end (same as release end)
  b[11] = b[10];
  return { b,
    idx: { NOTE_ON:0, DELAY_END:1, ATTACK_MID:2, ATTACK_END:3, HOLD_MID:4, HOLD_END:5, DECAY_MID:6, DECAY_END:7, NOTE_OFF:8, RELEASE_MID:9, RELEASE_END:10, TOTAL_END:11 }
  };
}

// === Canvas + rendering ===
const canvas = document.getElementById('env');
const ctx = canvas.getContext('2d');
const noteOffEl = document.getElementById('noteoff');
const sustainLine = document.getElementById('sustainLine');
let params = { // safe defaults avoid early draw errors
  delay:0, attack:0, hold:0, decay:0, release:0, gate:0,
  sustain:1, attack_power:0, decay_power:0, release_power:0
};


function resize()
{
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round((window.innerHeight - 120) * dpr);
  draw();
}
window.addEventListener('resize', resize);

function drawGrid(bounds)
{
  const {w,h,pxPerSec} = bounds;
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  const secLines = Math.ceil(w / pxPerSec);
  for(let i=0;i<=secLines;i++){
    const x = Math.round(i*pxPerSec)+0.5; ctx.moveTo(x, 0); ctx.lineTo(x, h);
  }
  for(let i=0;i<=4;i++){
    const y = Math.round((i/4)*h)+0.5; ctx.moveTo(0, y); ctx.lineTo(w, y);
  }
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.font = `${Math.max(10, h*0.015)}px Arial Narrow`;
  ctx.textBaseline = 'top';
  for(let i=0;i<=secLines;i++) ctx.fillText(`${i}`, i*pxPerSec + 4, 4);
  ctx.restore();
}

function draw(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  const marginL = 18*dpr, marginR = 12*dpr, marginT = 16*dpr, marginB = 20*dpr;
  const innerW = w - marginL - marginR;
  const innerH = h - marginT - marginB;

  // Precompute timeline once per draw
  const TL = computeTimeline(params);
  const b = TL.b, I = TL.idx;
  const totalSec = Math.max(0.0001, ticksToSec(b[I.TOTAL_END]));
  const invTotal = 1 / totalSec;
  const pxPerSec = innerW / totalSec;
  const bounds = {w:innerW, h:innerH, pxPerSec};

  ctx.save();
  ctx.translate(marginL, marginT);
  drawGrid(bounds);

  sustainLine.style.display = 'block';
  sustainLine.style.top = `${marginT + (1-params.sustain)*innerH}px`;

  // === Render by sampling, using 16-bit tick boundaries for time positions ===
  const steps = Math.max(800, innerW|0);
  const xs = new Float32Array(steps+1);
  const ys = new Float32Array(steps+1);
  const invSteps = 1 / steps;
  for(let i=0;i<=steps;i++){
    const f = i * invSteps;               // 0..1
    const t = f * totalSec;               // seconds
    xs[i] = f * innerW;
    ys[i] = (1 - evalEnvelope(params, t)) * innerH;
  }
  ctx.beginPath();
  ctx.moveTo(xs[0], ys[0]);
  for(let i=1;i<=steps;i++) ctx.lineTo(xs[i], ys[i]);
  ctx.lineWidth = 2*dpr;
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.shadowColor = 'rgba(125,211,252,0.2)';
  ctx.shadowBlur = 10*dpr;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // === Draw boundary dots (key segment ends) ===
  ctx.fillStyle = 'rgba(125,211,252,0.9)';
  const boundaryIdx = [I.NOTE_ON, I.DELAY_END, I.ATTACK_END, I.HOLD_END, I.DECAY_END, I.NOTE_OFF, I.TOTAL_END];
  for (let k=0;k<boundaryIdx.length;k++){
    const t = ticksToSec(b[boundaryIdx[k]]);
    const x = (t * invTotal) * innerW;
    const y = (1 - evalEnvelope(params, t)) * innerH;
    ctx.beginPath(); ctx.arc(x, y, 3*dpr, 0, Math.PI*2); ctx.fill();
  }

  // === Draw midpoint labels using the indexed array ===
  ctx.save();
  ctx.fillStyle = 'rgba(255, 225, 120, 0.95)';
  ctx.font = `${Math.max(10, innerH*0.03)}px ui-sans-serif`; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  function dotLabel(xPix, yPix, label){ ctx.beginPath(); ctx.arc(xPix, yPix, 3.5*dpr, 0, Math.PI*2); ctx.fill(); ctx.fillText(label, xPix + 6*dpr, yPix); }
  const mids = [ [I.ATTACK_MID,'A'], [I.DECAY_MID,'D'], [I.RELEASE_MID,'R'] ];
  for (let j=0;j<mids.length;j++){
    const t = ticksToSec(b[mids[j][0]]);
    const x = (t * invTotal) * innerW;
    const y = (1 - evalEnvelope(params, t)) * innerH;
    dotLabel(x, y, mids[j][1]);
  }
  ctx.restore();

  ctx.restore();

  // Note-off guide
  const noteOffX = marginL + (ticksToSec(b[I.NOTE_OFF]) * invTotal) * innerW;
  noteOffEl.style.left = `${noteOffX}px`;
}

// === Controls ===
function bind(id, key, formatter=(v)=>v, transform=(v)=>v){
  const el = document.getElementById(id);
  const vEl  = document.getElementById(id+"_v");
  const sync = (useTransform=true)=>{
    const raw = +el.value;
    vEl.textContent = formatter(raw);
    params[key] = useTransform ? transform(raw) : raw;
    draw();
  };
  el.addEventListener('input', ()=>sync(true));
  return {el, vEl, sync, formatter, transform};
}

const B = {
  gate: bind('gate','gate', v=>v.toFixed(2)+'s'),
  // Time sliders are in RAW PATCH UNITS (log feel via power2 mapping); display seconds
  delay:   bind('delay','delay',   v=> fromPatchUnits('env_delay', v).toFixed(3)+'s',   v=> fromPatchUnits('env_delay', v)),
  attack:  bind('attack','attack', v=> fromPatchUnits('env_attack', v).toFixed(3)+'s',  v=> fromPatchUnits('env_attack', v)),
  hold:    bind('hold','hold',     v=> fromPatchUnits('env_hold', v).toFixed(3)+'s',    v=> fromPatchUnits('env_hold', v)),
  decay:   bind('decay','decay',   v=> fromPatchUnits('env_decay', v).toFixed(3)+'s',   v=> fromPatchUnits('env_decay', v)),
  release: bind('release','release',v=> fromPatchUnits('env_release', v).toFixed(3)+'s',v=> fromPatchUnits('env_release', v)),
  // Power and sustain remain linear in native units
  attack_power: bind('attack_power','attack_power',  v=>v.toFixed(3), v=>-v),
  decay_power:  bind('decay_power','decay_power',    v=>v.toFixed(3), v=>v),
  sustain:      bind('sustain','sustain',            v=>v.toFixed(3)),
  release_power:bind('release_power','release_power',v=>v.toFixed(3), v=>v),
};

function setControlsFromRaw(p){
  for(const k in B){
    if (p[k] == null) continue;
    B[k].el.value = p[k];
    B[k].sync(true);
  }
}

function reset(){
  // PRESET is in raw patch units for time; set sliders to raw and sync (seconds computed via transform)
  const raw = {
    delay: PRESET["env_"+ENV_INDEX+"_delay"],
    attack: PRESET["env_"+ENV_INDEX+"_attack"],
    hold: PRESET["env_"+ENV_INDEX+"_hold"],
    decay: PRESET["env_"+ENV_INDEX+"_decay"],
    release: PRESET["env_"+ENV_INDEX+"_release"],
    sustain: PRESET["env_"+ENV_INDEX+"_sustain"],
    attack_power: PRESET["env_"+ENV_INDEX+"_attack_power"],
    decay_power: PRESET["env_"+ENV_INDEX+"_decay_power"],
    release_power: PRESET["env_"+ENV_INDEX+"_release_power"],
    gate: 0
  };
  setControlsFromRaw(raw);
  setPresetStyleLabels();
  draw();
}

document.getElementById('reset').addEventListener('click', reset);
document.getElementById('fit').addEventListener('click', ()=> draw());

// === Preset-style label names ===
function setPresetStyleLabels(){
  const prefix = `env_${ENV_INDEX}_`;
  const map = {
    label_gate: prefix + 'sustain',          // Gate (sustain time) -> env_sustain
    label_delay: prefix + 'delay',
    label_attack: prefix + 'attack',
    label_attack_power: prefix + 'attack_power',
    label_hold: prefix + 'hold',
    label_decay: prefix + 'decay',
    label_decay_power: prefix + 'decay_power',
    label_sustain: prefix + 'sustain',       // Sustain (0–1) -> env_sustain
    label_release: prefix + 'release',
    label_release_power: prefix + 'release_power'
  };
  Object.entries(map).forEach(([id, text])=>{ const el = document.getElementById(id); if (el) el.textContent = text; });
}

// === Diagnostics / Tests ===
function runTests(){
  const out = [];
  const ok = (name, cond)=>{ out.push(`${cond ? '✔' : '✘'} ${name}`); };
  const near = (a,b,eps=1e-6)=> Math.abs(a-b) <= eps;

  // 0) Scales exist for all expected keys
  const timeKeys = ['env_attack','env_decay','env_release','env_delay','env_hold'];
  ok('PARAM_SCALES has time keys', timeKeys.every(k=> PARAM_SCALES[k] && PARAM_SCALES[k].rawMax>0 && PARAM_SCALES[k].secMax>0));

  // 0a) computeTimeline ordering & coverage
  const Pz = {delay:0.1, attack:0.2, hold:0.3, decay:0.4, sustain:0.5, release:0.6, gate:0.7};
  const TLz = computeTimeline(Pz);
  const b = TLz.b, I = TLz.idx;
  ok('computeTimeline ordered', b[I.NOTE_ON] <= b[I.DELAY_END] && b[I.DELAY_END] <= b[I.ATTACK_END] && b[I.ATTACK_END] <= b[I.HOLD_END] && b[I.HOLD_END] <= b[I.DECAY_END] && b[I.DECAY_END] <= b[I.NOTE_OFF] && b[I.NOTE_OFF] <= b[I.RELEASE_END]);
  ok('total equals release end', b[I.TOTAL_END] === b[I.RELEASE_END]);
  ok('midpoints centered', b[I.ATTACK_MID] === ((b[I.DELAY_END]+b[I.ATTACK_END])>>>1) && b[I.DECAY_MID] === ((b[I.HOLD_END]+b[I.DECAY_END])>>>1) && b[I.RELEASE_MID] === ((b[I.NOTE_OFF]+b[I.RELEASE_END])>>>1));

  // 0b) ticks <-> seconds round-trip within 1 tick
  const tSec = 1.234;
  ok('ticks<->sec roundtrip', Math.abs(ticksToSec(secToTicks(tSec)) - tSec) <= SEC_PER_TICK);

  // 1) powerCurve01 endpoints & linearity
  ok('powerCurve01(0,p)=0 for p∈{-20,-3,0,3,20}', [-20,-3,0,3,20].every(p=> near(powerCurve01(0,p),0)));
  ok('powerCurve01(1,p)=1 for p∈{-20,-3,0,3,20}', [-20,-3,0,3,20].every(p=> near(powerCurve01(1,p),1)));
  ok('powerCurve01 linear at p=0', [0,0.25,0.5,0.75,1].every(x=> near(powerCurve01(x,0), x, 1e-9)));

  // 2) 16-bit tick timeline properties
  const Pt = {delay:0.2, attack:0.3, hold:0.1, decay:0.2, sustain:0.5, release:0.4, gate:0.0};
  const TLt = computeTimeline(Pt);
  ok('Ticks within 0..65535', (()=>{ const b=TLt.b; for(let i=0;i<b.length;i++){ if(b[i]<0||b[i]>U16_MAX) return false; } return true; })());
  ok('Total end equals release end (ticks)', TLt.b[TLt.idx.TOTAL_END] === TLt.b[TLt.idx.RELEASE_END]);
  ok('Midpoints are integer mid-ticks', (
    TLt.b[TLt.idx.ATTACK_MID] === ((TLt.b[TLt.idx.DELAY_END] + TLt.b[TLt.idx.ATTACK_END]) >>> 1) &&
    TLt.b[TLt.idx.DECAY_MID]  === ((TLt.b[TLt.idx.HOLD_END]  + TLt.b[TLt.idx.DECAY_END])  >>> 1) &&
    TLt.b[TLt.idx.RELEASE_MID]=== ((TLt.b[TLt.idx.NOTE_OFF]   + TLt.b[TLt.idx.RELEASE_END])>>> 1)
  ));

  // 2b) Sum-of-segments -> end tick equality
  const Px = {delay:0.11, attack:0.22, hold:0.33, decay:0.44, gate:0.55, release:0.66};
  const TLx = computeTimeline(Px);
  ok('TOTAL_END == secToTicks(sum secs)', TLx.b[TLx.idx.TOTAL_END] === secToTicks(totalLength(Px)));

  // 3) Envelope midpoints at t=50% reflect power mapping at t=50% reflect power mapping
  const P = {...params, delay:0, attack:1, hold:0, decay:1, release:1, gate:0.2, sustain:0.7, attack_power:2, decay_power:-1, release_power:1};
  ok('Attack midpoint equals mapped power', near(evalEnvelope(P, 0.5 * P.attack), powerCurve01(0.5, P.attack_power), 1e-6));
  ok('Decay midpoint equals mapped power', near(evalEnvelope(P, P.attack + 0.5 * P.decay), lerp(1, P.sustain, powerCurve01(0.5, P.decay_power)), 1e-6));
  ok('Release midpoint equals mapped power', near(evalEnvelope(P, P.attack + P.decay + P.gate + 0.5 * P.release), lerp(P.sustain, 0, powerCurve01(0.5, P.release_power)), 1e-6));

  // 4) Flat segments: delay/hold constant values
  const P2 = {delay:0.3, attack:0.2, hold:0.4, decay:0.1, sustain:0.6, release:0.2, gate:0.1, attack_power:0, decay_power:0, release_power:0};
  ok('Delay segment stays at 0', [0.0,0.05,0.15,0.29].every(ts=> near(evalEnvelope(P2, ts), 0)));
  ok('Hold segment stays at 1', [P2.delay+P2.attack+0.05, P2.delay+P2.attack+P2.hold-0.01].every(ts=> near(evalEnvelope(P2, ts), 1)));

  // 5) Range safety: envelope stays in [0,1]
  const P3 = {...params, delay:0.1, attack:0.2, hold:0.2, decay:0.2, release:0.2, gate:0.3, sustain:0.65, attack_power:20, decay_power:-20, release_power:20};
  const TL3 = computeTimeline(P3); const total3 = ticksToSec(TL3.b[TL3.idx.TOTAL_END]);
  let inRange = true; for(let i=0;i<=200;i++){ const y=evalEnvelope(P3, (i/200)*total3); if (y< -1e-6 || y>1+1e-6) { inRange=false; break; } }
  ok('Envelope output clamped to [0,1]', inRange);

  // 6) Monotonicity checks in segments
  function isMonoInc(arr){ for(let i=1;i<arr.length;i++){ if(arr[i] + 1e-6 < arr[i-1]) return false; } return true; }
  function isMonoDec(arr){ for(let i=1;i<arr.length;i++){ if(arr[i] - 1e-6 > arr[i-1]) return false; } return true; }
  const Pa = {delay:0, attack:0.6, hold:0, decay:0, release:0, gate:0, sustain:1, attack_power:10, decay_power:0, release_power:0};
  const TL_a = computeTimeline(Pa); const valsA = Array.from({length:50},(_,i)=> evalEnvelope(Pa, (i/49)*ticksToSec(TL_a.b[TL_a.idx.ATTACK_END])));
  ok('Attack monotonic non-decreasing', isMonoInc(valsA));
  const Pd = {delay:0, attack:0, hold:0, decay:0.6, release:0, gate:0, sustain:0.4, attack_power:0, decay_power:-10, release_power:0};
  const TL_d = computeTimeline(Pd); const valsD = Array.from({length:50},(_,i)=> evalEnvelope(Pd, ticksToSec(TL_d.b[TL_d.idx.HOLD_END]) + (i/49)*(ticksToSec(TL_d.b[TL_d.idx.DECAY_END]) - ticksToSec(TL_d.b[TL_d.idx.HOLD_END]))));
  ok('Decay monotonic towards sustain', isMonoDec(valsD));
  const Pr = {delay:0, attack:0, hold:0, decay:0, release:0.6, gate:0, sustain:0.7, attack_power:0, decay_power:0, release_power:10};
  const TL_r = computeTimeline(Pr); const valsR = Array.from({length:50},(_,i)=> evalEnvelope(Pr, ticksToSec(TL_r.b[TL_r.idx.NOTE_OFF]) + (i/49)*(ticksToSec(TL_r.b[TL_r.idx.RELEASE_END]) - ticksToSec(TL_r.b[TL_r.idx.NOTE_OFF]))));
  ok('Release monotonic non-increasing', isMonoDec(valsR));

  // 7) Preset powers transformed at init so bends match slider behavior
  ok('Preset powers transformed at init',
     B.attack_power.transform(PRESET["env_"+ENV_INDEX+"_attack_power"]) === params.attack_power &&
     B.decay_power.transform(PRESET["env_"+ENV_INDEX+"_decay_power"])   === params.decay_power &&
     B.release_power.transform(PRESET["env_"+ENV_INDEX+"_release_power"])=== params.release_power
  );
  ok('Slider transform mapping (A negates, D/R identity)',
     B.attack_power.transform(5) === -5 &&
     B.decay_power.transform(-7) === -7 &&
     B.release_power.transform(3) === 3
  );

  // 8) Labels visually renamed to preset-style with configurable n
  const prefix = `env_${ENV_INDEX}_`;
  const labelsOk = (
    document.getElementById('label_gate')?.textContent === prefix+'sustain' &&
    document.getElementById('label_delay')?.textContent === prefix+'delay' &&
    document.getElementById('label_attack')?.textContent === prefix+'attack' &&
    document.getElementById('label_attack_power')?.textContent === prefix+'attack_power' &&
    document.getElementById('label_hold')?.textContent === prefix+'hold' &&
    document.getElementById('label_decay')?.textContent === prefix+'decay' &&
    document.getElementById('label_decay_power')?.textContent === prefix+'decay_power' &&
    document.getElementById('label_sustain')?.textContent === prefix+'sustain' &&
    document.getElementById('label_release')?.textContent === prefix+'release' &&
    document.getElementById('label_release_power')?.textContent === prefix+'release_power'
  );
  ok('Preset-style labels applied', labelsOk);

  // 9) Direct unit tests for monotonic helpers
  ok('isMonoInc basic pass/fail', isMonoInc([0,0,1,2,2]) && !isMonoInc([0,1,0]));
  ok('isMonoDec basic pass/fail', isMonoDec([3,3,2,1,1]) && !isMonoDec([3,2,3]));

  // 10) Power-law scaling sanity checks + round-trips
  const A = PARAM_SCALES.env_attack; // 32s family
  const Y = PARAM_SCALES.env_delay;  // 4s family
  ok('Attack midpoint → 2s (32/16)', Math.abs(fromPatchUnits('env_attack', A.rawMax/2) - (A.secMax/16)) < 1e-6);
  ok('Delay midpoint → 0.25s (4/16)', Math.abs(fromPatchUnits('env_delay', Y.rawMax/2) - (Y.secMax/16)) < 1e-6);
  ok('Delay raw≈1.004971 → ≈1.020s', Math.abs(fromPatchUnits('env_delay', 1.0049711465835571) - 1.020) < 0.003);
  ok('Attack-family raw≈1.19417548 → ≈2.033s', Math.abs(fromPatchUnits('env_attack', 1.1941754817962646) - 2.033) < 0.003);
  ok('Attack round-trip 32s -> rawMax', Math.abs(toPatchUnits('env_attack', 32) - A.rawMax) < 1e-9);
  ok('Delay round-trip 4s -> rawMax', Math.abs(toPatchUnits('env_delay', 4) - Y.rawMax) < 1e-9);

  // 11) Slider ranges match RAW MAX (log-feel), not seconds
  ok('Attack/Decay/Release sliders max=rawMax(2.3784)', ['attack','decay','release'].every(id=> Math.abs(+document.getElementById(id).max - 2.378420114517212) < 1e-12));
  ok('Delay/Hold sliders max=rawMax(1.4142)', ['delay','hold'].every(id=> Math.abs(+document.getElementById(id).max - 1.4142135381698608) < 1e-12));

  // 12) After reset, params hold seconds converted from PRESET raw
  ok('params.attack equals seconds(from raw)', near(params.attack, fromPatchUnits('env_attack', PRESET["env_"+ENV_INDEX+"_attack"])));
  ok('params.delay equals seconds(from raw)', near(params.delay, fromPatchUnits('env_delay', PRESET["env_"+ENV_INDEX+"_delay"])));

  // 13) Inverse mapping property on a mid value
  const rawMidA = A.rawMax/2; const secMidA = fromPatchUnits('env_attack', rawMidA); const backRawA = toPatchUnits('env_attack', secMidA);
  ok('attack rawMid -> sec -> raw round-trip', near(backRawA, rawMidA, 1e-9));

  const pre = document.getElementById('testout');
  if (pre) pre.textContent = out.join('\n');
}

// Initialize
reset();
resize();
runTests();
</script>
</body>
</html>
